const request = require('supertest');
const mongoose = require('mongoose');
const app = require('../server');
const Order = require('../models/Order');
const { AdminUser } = require('../models/AdminUser');

describe('Enhanced Order Management System', () => {
  let adminToken;
  let testOrder;
  let testAdmin;

  beforeAll(async () => {
    // Create test admin user
    testAdmin = new AdminUser({
      email: 'admin@test.com',
      passwordHash: 'hashedpassword',
      role: {
        name: 'SuperAdmin',
        level: 1,
        permissions: [
          { resource: 'orders', actions: ['create', 'read', 'update', 'delete'] }
        ]
      },
      profile: {
        firstName: 'Test',
        lastName: 'Admin'
      },
      isActive: true
    });
    await testAdmin.save();

    // Mock admin token (in real app, this would be generated by auth)
    adminToken = 'mock-admin-token';
  });

  beforeEach(async () => {
    // Create test order
    testOrder = new Order({
      orderId: 'TEST-ORDER-001',
      customerId: new mongoose.Types.ObjectId(),
      products: [{
        productId: new mongoose.Types.ObjectId(),
        name: 'Test Product',
        sku: 'TEST-SKU-001',
        quantity: 1,
        price: 1000,
        category: 'Test Category'
      }],
      totalAmount: 1000,
      finalAmount: 1180,
      taxAmount: 180,
      status: 'pending',
      paymentStatus: 'pending',
      paymentMethod: 'razorpay',
      customerInfo: {
        firstName: 'Test',
        lastName: 'Customer',
        email: 'test@customer.com',
        phone: '+91 9876543210'
      }
    });
    await testOrder.save();
  });

  afterEach(async () => {
    await Order.deleteMany({});
  });

  afterAll(async () => {
    await AdminUser.deleteMany({});
    await mongoose.connection.close();
  });

  describe('GET /api/orders - Enhanced Admin Order Listing', () => {
    test('should return orders with analytics', async () => {
      const response = await request(app)
        .get('/api/orders')
        .query({
          page: 1,
          limit: 20,
          status: 'all',
          paymentStatus: 'all'
        });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveProperty('orders');
      expect(response.body.data).toHaveProperty('analytics');
      expect(response.body.data).toHaveProperty('pagination');
      expect(Array.isArray(response.body.data.orders)).toBe(true);
    });

    test('should filter orders by status', async () => {
      const response = await request(app)
        .get('/api/orders')
        .query({ status: 'pending' });

      expect(response.status).toBe(200);
      expect(response.body.data.orders.every(order => order.status === 'pending')).toBe(true);
    });

    test('should search orders by customer email', async () => {
      const response = await request(app)
        .get('/api/orders')
        .query({ search: 'test@customer.com' });

      expect(response.status).toBe(200);
      expect(response.body.data.orders.length).toBeGreaterThan(0);
    });
  });

  describe('GET /api/orders/dashboard/analytics - Order Analytics', () => {
    test('should return comprehensive analytics', async () => {
      const response = await request(app)
        .get('/api/orders/dashboard/analytics')
        .query({ period: '30d' });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveProperty('totalOrders');
      expect(response.body.data).toHaveProperty('totalRevenue');
      expect(response.body.data).toHaveProperty('avgOrderValue');
      expect(response.body.data).toHaveProperty('statusBreakdown');
      expect(response.body.data).toHaveProperty('paymentBreakdown');
      expect(response.body.data).toHaveProperty('dailyTrend');
      expect(response.body.data).toHaveProperty('topCustomers');
      expect(response.body.data).toHaveProperty('flaggedOrders');
    });
  });

  describe('GET /api/orders/:orderId/customer-insights - Customer Insights', () => {
    test('should return customer insights for an order', async () => {
      const response = await request(app)
        .get(`/api/orders/${testOrder.orderId}/customer-insights`);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveProperty('customer');
      expect(response.body.data).toHaveProperty('orderHistory');
      expect(response.body.data).toHaveProperty('metrics');
      expect(response.body.data.metrics).toHaveProperty('totalOrders');
      expect(response.body.data.metrics).toHaveProperty('totalSpent');
      expect(response.body.data.metrics).toHaveProperty('segment');
      expect(response.body.data.metrics).toHaveProperty('riskLevel');
    });
  });

  describe('POST /api/orders/:orderId/flag - Flag Order', () => {
    test('should flag an order for review', async () => {
      const flagData = {
        flagType: 'manual_review',
        reason: 'Suspicious activity detected',
        severity: 'high'
      };

      const response = await request(app)
        .post(`/api/orders/${testOrder.orderId}/flag`)
        .send(flagData);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      
      // Verify flag was added
      const updatedOrder = await Order.findOne({ orderId: testOrder.orderId });
      expect(updatedOrder.flags).toHaveLength(1);
      expect(updatedOrder.flags[0].type).toBe('manual_review');
      expect(updatedOrder.flags[0].reason).toBe('Suspicious activity detected');
      expect(updatedOrder.flags[0].severity).toBe('high');
    });
  });

  describe('POST /api/orders/:orderId/refund - Process Refund', () => {
    beforeEach(async () => {
      // Set order as paid for refund testing
      testOrder.paymentStatus = 'paid';
      await testOrder.save();
    });

    test('should process a full refund', async () => {
      const refundData = {
        amount: testOrder.finalAmount,
        reason: 'Customer requested refund',
        refundType: 'full'
      };

      const response = await request(app)
        .post(`/api/orders/${testOrder.orderId}/refund`)
        .send(refundData);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      
      // Verify refund was processed
      const updatedOrder = await Order.findOne({ orderId: testOrder.orderId });
      expect(updatedOrder.paymentStatus).toBe('refunded');
      expect(updatedOrder.status).toBe('cancelled');
      expect(updatedOrder.refundInfo).toBeDefined();
      expect(updatedOrder.refundInfo.amount).toBe(testOrder.finalAmount);
    });

    test('should not allow refund on unpaid order', async () => {
      // Set order as pending payment
      testOrder.paymentStatus = 'pending';
      await testOrder.save();

      const refundData = {
        amount: testOrder.finalAmount,
        reason: 'Test refund',
        refundType: 'full'
      };

      const response = await request(app)
        .post(`/api/orders/${testOrder.orderId}/refund`)
        .send(refundData);

      expect(response.status).toBe(400);
      expect(response.body.success).toBe(false);
      expect(response.body.message).toContain('Cannot refund unpaid order');
    });
  });

  describe('PATCH /api/orders/bulk/status - Bulk Status Update', () => {
    let testOrder2;

    beforeEach(async () => {
      testOrder2 = new Order({
        orderId: 'TEST-ORDER-002',
        customerId: new mongoose.Types.ObjectId(),
        products: [{
          productId: new mongoose.Types.ObjectId(),
          name: 'Test Product 2',
          sku: 'TEST-SKU-002',
          quantity: 1,
          price: 2000,
          category: 'Test Category'
        }],
        totalAmount: 2000,
        finalAmount: 2360,
        taxAmount: 360,
        status: 'pending',
        paymentStatus: 'pending',
        paymentMethod: 'razorpay',
        customerInfo: {
          firstName: 'Test',
          lastName: 'Customer 2',
          email: 'test2@customer.com',
          phone: '+91 9876543211'
        }
      });
      await testOrder2.save();
    });

    test('should update multiple orders status', async () => {
      const bulkUpdateData = {
        orderIds: [testOrder.orderId, testOrder2.orderId],
        status: 'processing',
        reason: 'Bulk status update test'
      };

      const response = await request(app)
        .patch('/api/orders/bulk/status')
        .send(bulkUpdateData);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data.successful).toHaveLength(2);
      expect(response.body.data.failed).toHaveLength(0);

      // Verify orders were updated
      const updatedOrder1 = await Order.findOne({ orderId: testOrder.orderId });
      const updatedOrder2 = await Order.findOne({ orderId: testOrder2.orderId });
      
      expect(updatedOrder1.status).toBe('processing');
      expect(updatedOrder2.status).toBe('processing');
    });
  });

  describe('Order Model Static Methods', () => {
    test('should get revenue by period', async () => {
      // Set order as paid
      testOrder.paymentStatus = 'paid';
      await testOrder.save();

      const startDate = new Date();
      startDate.setDate(startDate.getDate() - 30);
      const endDate = new Date();

      const revenue = await Order.getRevenueByPeriod(startDate, endDate, 'day');
      
      expect(Array.isArray(revenue)).toBe(true);
    });

    test('should get top customers', async () => {
      const topCustomers = await Order.getTopCustomers(10);
      
      expect(Array.isArray(topCustomers)).toBe(true);
    });

    test('should get flagged orders', async () => {
      // Add a flag to the test order
      await testOrder.addFlag({
        type: 'manual_review',
        reason: 'Test flag',
        severity: 'medium'
      }, testAdmin._id);

      const flaggedOrders = await Order.getFlaggedOrders();
      
      expect(Array.isArray(flaggedOrders)).toBe(true);
      expect(flaggedOrders.length).toBeGreaterThan(0);
    });
  });

  describe('Order Model Instance Methods', () => {
    test('should add flag to order', async () => {
      const flagData = {
        type: 'payment_issue',
        reason: 'Payment failed multiple times',
        severity: 'high'
      };

      await testOrder.addFlag(flagData, testAdmin._id);
      
      expect(testOrder.flags).toHaveLength(1);
      expect(testOrder.flags[0].type).toBe('payment_issue');
      expect(testOrder.flags[0].createdBy.toString()).toBe(testAdmin._id.toString());
    });

    test('should resolve flag', async () => {
      // First add a flag
      await testOrder.addFlag({
        type: 'manual_review',
        reason: 'Test flag',
        severity: 'medium'
      }, testAdmin._id);

      const flagId = testOrder.flags[0]._id;
      await testOrder.resolveFlag(flagId, testAdmin._id, 'Issue resolved');

      expect(testOrder.flags[0].resolved).toBe(true);
      expect(testOrder.flags[0].resolvedBy.toString()).toBe(testAdmin._id.toString());
      expect(testOrder.flags[0].notes).toBe('Issue resolved');
    });

    test('should process refund', async () => {
      const refundData = {
        amount: 500,
        reason: 'Partial refund',
        refundType: 'partial'
      };

      await testOrder.processRefund(refundData, testAdmin._id);

      expect(testOrder.paymentStatus).toBe('refunded');
      expect(testOrder.status).toBe('cancelled');
      expect(testOrder.refundInfo.amount).toBe(500);
      expect(testOrder.refundInfo.processedBy.toString()).toBe(testAdmin._id.toString());
    });

    test('should update shipping information', async () => {
      const trackingNumber = 'TRK123456789';
      const carrier = 'BlueDart';
      const estimatedDelivery = new Date();
      estimatedDelivery.setDate(estimatedDelivery.getDate() + 3);

      await testOrder.updateShipping(trackingNumber, carrier, estimatedDelivery);

      expect(testOrder.trackingNumber).toBe(trackingNumber);
      expect(testOrder.shippingCarrier).toBe(carrier);
      expect(testOrder.estimatedDelivery).toEqual(estimatedDelivery);
      expect(testOrder.status).toBe('shipped');
    });

    test('should mark order as delivered', async () => {
      const deliveryDate = new Date();
      await testOrder.markDelivered(deliveryDate);

      expect(testOrder.status).toBe('delivered');
      expect(testOrder.actualDelivery).toEqual(deliveryDate);
    });
  });
});